# 0. 导读

![image-20240328141654963](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240328141654963.png)

![image-20240328142018434](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240328142018434.png)

![image-20240328143239466](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240328143239466.png)



# 1. 环境搭建

前端打包到 nginx 直接使用

![image-20240328144648324](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240328144648324.png)



## 1.2 数据库设计

| 序号 | 数据表名      | 中文名称       |
| ---- | ------------- | -------------- |
| 1    | employee      | 员工表         |
| 2    | category      | 分类表         |
| 3    | dish          | 菜品表         |
| 4    | dish_flavor   | 菜品口味表     |
| 5    | setmeal       | 套餐表         |
| 6    | setmeal_dish  | 套餐菜品关系表 |
| 7    | user          | 用户表         |
| 8    | address_book  | 地址表         |
| 9    | shopping_cart | 购物车表       |
| 10   | orders        | 订单表         |
| 11   | order_detail  | 订单明细表     |

### 1. employee

employee表为员工表，用于存储商家内部的员工信息。具体表结构如下：

| 字段名      | 数据类型    | 说明         | 备注        |
| ----------- | ----------- | ------------ | ----------- |
| id          | bigint      | 主键         | 自增        |
| name        | varchar(32) | 姓名         |             |
| username    | varchar(32) | 用户名       | 唯一        |
| password    | varchar(64) | 密码         |             |
| phone       | varchar(11) | 手机号       |             |
| sex         | varchar(2)  | 性别         |             |
| id_number   | varchar(18) | 身份证号     |             |
| status      | int         | 账号状态     | 1正常 0锁定 |
| create_time | datetime    | 创建时间     |             |
| update_time | datetime    | 最后修改时间 |             |
| create_user | bigint      | 创建人id     |             |
| update_user | bigint      | 最后修改人id |             |

### 2. category

category表为分类表，用于存储商品的分类信息。具体表结构如下：

| 字段名      | 数据类型    | 说明         | 备注                 |
| ----------- | ----------- | ------------ | -------------------- |
| id          | bigint      | 主键         | 自增                 |
| name        | varchar(32) | 分类名称     | 唯一                 |
| type        | int         | 分类类型     | 1菜品分类  2套餐分类 |
| sort        | int         | 排序字段     | 用于分类数据的排序   |
| status      | int         | 状态         | 1启用 0禁用          |
| create_time | datetime    | 创建时间     |                      |
| update_time | datetime    | 最后修改时间 |                      |
| create_user | bigint      | 创建人id     |                      |
| update_user | bigint      | 最后修改人id |                      |

### 3. dish

dish表为菜品表，用于存储菜品的信息。具体表结构如下：

| 字段名      | 数据类型      | 说明         | 备注        |
| ----------- | ------------- | ------------ | ----------- |
| id          | bigint        | 主键         | 自增        |
| name        | varchar(32)   | 菜品名称     | 唯一        |
| category_id | bigint        | 分类id       | 逻辑外键    |
| price       | decimal(10,2) | 菜品价格     |             |
| image       | varchar(255)  | 图片路径     |             |
| description | varchar(255)  | 菜品描述     |             |
| status      | int           | 售卖状态     | 1起售 0停售 |
| create_time | datetime      | 创建时间     |             |
| update_time | datetime      | 最后修改时间 |             |
| create_user | bigint        | 创建人id     |             |
| update_user | bigint        | 最后修改人id |             |

### 4. dish_flavor

dish_flavor表为菜品口味表，用于存储菜品的口味信息。具体表结构如下：

| 字段名  | 数据类型     | 说明     | 备注     |
| ------- | ------------ | -------- | -------- |
| id      | bigint       | 主键     | 自增     |
| dish_id | bigint       | 菜品id   | 逻辑外键 |
| name    | varchar(32)  | 口味名称 |          |
| value   | varchar(255) | 口味值   |          |

### 5. setmeal

setmeal表为套餐表，用于存储套餐的信息。具体表结构如下：

| 字段名      | 数据类型      | 说明         | 备注        |
| ----------- | ------------- | ------------ | ----------- |
| id          | bigint        | 主键         | 自增        |
| name        | varchar(32)   | 套餐名称     | 唯一        |
| category_id | bigint        | 分类id       | 逻辑外键    |
| price       | decimal(10,2) | 套餐价格     |             |
| image       | varchar(255)  | 图片路径     |             |
| description | varchar(255)  | 套餐描述     |             |
| status      | int           | 售卖状态     | 1起售 0停售 |
| create_time | datetime      | 创建时间     |             |
| update_time | datetime      | 最后修改时间 |             |
| create_user | bigint        | 创建人id     |             |
| update_user | bigint        | 最后修改人id |             |

### 6. setmeal_dish

setmeal_dish表为套餐菜品关系表，用于存储套餐和菜品的关联关系。具体表结构如下：

| 字段名     | 数据类型      | 说明     | 备注     |
| ---------- | ------------- | -------- | -------- |
| id         | bigint        | 主键     | 自增     |
| setmeal_id | bigint        | 套餐id   | 逻辑外键 |
| dish_id    | bigint        | 菜品id   | 逻辑外键 |
| name       | varchar(32)   | 菜品名称 | 冗余字段 |
| price      | decimal(10,2) | 菜品单价 | 冗余字段 |
| copies     | int           | 菜品份数 |          |

### 7. user

user表为用户表，用于存储C端用户的信息。具体表结构如下：

| 字段名      | 数据类型     | 说明               | 备注 |
| ----------- | ------------ | ------------------ | ---- |
| id          | bigint       | 主键               | 自增 |
| openid      | varchar(45)  | 微信用户的唯一标识 |      |
| name        | varchar(32)  | 用户姓名           |      |
| phone       | varchar(11)  | 手机号             |      |
| sex         | varchar(2)   | 性别               |      |
| id_number   | varchar(18)  | 身份证号           |      |
| avatar      | varchar(500) | 微信用户头像路径   |      |
| create_time | datetime     | 注册时间           |      |

### 8. address_book

address_book表为地址表，用于存储C端用户的收货地址信息。具体表结构如下：

| 字段名        | 数据类型     | 说明         | 备注           |
| ------------- | ------------ | ------------ | -------------- |
| id            | bigint       | 主键         | 自增           |
| user_id       | bigint       | 用户id       | 逻辑外键       |
| consignee     | varchar(50)  | 收货人       |                |
| sex           | varchar(2)   | 性别         |                |
| phone         | varchar(11)  | 手机号       |                |
| province_code | varchar(12)  | 省份编码     |                |
| province_name | varchar(32)  | 省份名称     |                |
| city_code     | varchar(12)  | 城市编码     |                |
| city_name     | varchar(32)  | 城市名称     |                |
| district_code | varchar(12)  | 区县编码     |                |
| district_name | varchar(32)  | 区县名称     |                |
| detail        | varchar(200) | 详细地址信息 | 具体到门牌号   |
| label         | varchar(100) | 标签         | 公司、家、学校 |
| is_default    | tinyint(1)   | 是否默认地址 | 1是 0否        |

### 9. shopping_cart

shopping_cart表为购物车表，用于存储C端用户的购物车信息。具体表结构如下：

| 字段名      | 数据类型      | 说明         | 备注     |
| ----------- | ------------- | ------------ | -------- |
| id          | bigint        | 主键         | 自增     |
| name        | varchar(32)   | 商品名称     |          |
| image       | varchar(255)  | 商品图片路径 |          |
| user_id     | bigint        | 用户id       | 逻辑外键 |
| dish_id     | bigint        | 菜品id       | 逻辑外键 |
| setmeal_id  | bigint        | 套餐id       | 逻辑外键 |
| dish_flavor | varchar(50)   | 菜品口味     |          |
| number      | int           | 商品数量     |          |
| amount      | decimal(10,2) | 商品单价     |          |
| create_time | datetime      | 创建时间     |          |

### 10. orders

orders表为订单表，用于存储C端用户的订单数据。具体表结构如下：

| 字段名                  | 数据类型      | 说明         | 备注                                            |
| ----------------------- | ------------- | ------------ | ----------------------------------------------- |
| id                      | bigint        | 主键         | 自增                                            |
| number                  | varchar(50)   | 订单号       |                                                 |
| status                  | int           | 订单状态     | 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消 |
| user_id                 | bigint        | 用户id       | 逻辑外键                                        |
| address_book_id         | bigint        | 地址id       | 逻辑外键                                        |
| order_time              | datetime      | 下单时间     |                                                 |
| checkout_time           | datetime      | 付款时间     |                                                 |
| pay_method              | int           | 支付方式     | 1微信支付 2支付宝支付                           |
| pay_status              | tinyint       | 支付状态     | 0未支付 1已支付 2退款                           |
| amount                  | decimal(10,2) | 订单金额     |                                                 |
| remark                  | varchar(100)  | 备注信息     |                                                 |
| phone                   | varchar(11)   | 手机号       |                                                 |
| address                 | varchar(255)  | 详细地址信息 |                                                 |
| user_name               | varchar(32)   | 用户姓名     |                                                 |
| consignee               | varchar(32)   | 收货人       |                                                 |
| cancel_reason           | varchar(255)  | 订单取消原因 |                                                 |
| rejection_reason        | varchar(255)  | 拒单原因     |                                                 |
| cancel_time             | datetime      | 订单取消时间 |                                                 |
| estimated_delivery_time | datetime      | 预计送达时间 |                                                 |
| delivery_status         | tinyint       | 配送状态     | 1立即送出  0选择具体时间                        |
| delivery_time           | datetime      | 送达时间     |                                                 |
| pack_amount             | int           | 打包费       |                                                 |
| tableware_number        | int           | 餐具数量     |                                                 |
| tableware_status        | tinyint       | 餐具数量状态 | 1按餐量提供  0选择具体数量                      |

### 11. order_detail

order_detail表为订单明细表，用于存储C端用户的订单明细数据。具体表结构如下：

| 字段名      | 数据类型      | 说明         | 备注     |
| ----------- | ------------- | ------------ | -------- |
| id          | bigint        | 主键         | 自增     |
| name        | varchar(32)   | 商品名称     |          |
| image       | varchar(255)  | 商品图片路径 |          |
| order_id    | bigint        | 订单id       | 逻辑外键 |
| dish_id     | bigint        | 菜品id       | 逻辑外键 |
| setmeal_id  | bigint        | 套餐id       | 逻辑外键 |
| dish_flavor | varchar(50)   | 菜品口味     |          |
| number      | int           | 商品数量     |          |
| amount      | decimal(10,2) | 商品单价     |          |



# 2. 员工管理模块

![image-20240328155756853](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240328155756853.png)



## 2.1 新增员工

![image-20240328160213424](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240328160213424.png)

![image-20240328160435693](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240328160435693.png)

![image-20240328160452287](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240328160452287.png)

![image-20240328160634374](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240328160634374.png)

![image-20240328160651623](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240328160651623.png)

![image-20240329095003160](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240329095003160.png)

1. 设置全局异常处理器解决

2. 通过 JWT 令牌获取用户id

![image-20240329100856085](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240329100856085.png)

![image-20240329100927649](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240329100927649.png)

![image-20240329101004428](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240329101004428.png)

![image-20240329101448608](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240329101448608.png)

在拦截器获取 employeeId 放入

在 service/controller 获取



## 2.2 分页查询

![image-20240329104303739](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240329104303739.png)

![image-20240329104610436](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240329104610436.png)

日期无法正常显示

![image-20240329144346427](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240329144346427.png)



## 2.3 启用禁用员工账号

![image-20240329145025464](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240329145025464.png)

前端传回的Long型数据丢失解决办法：

在 JacksonObjectMapper 中添加下面最后两项

```java
SimpleModule simpleModule = new SimpleModule()
        .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
        .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
        .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
        .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
        .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
        .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
        .addSerializer(BigInteger.class, ToStringSerializer.instance)
        .addSerializer(Long.class, ToStringSerializer.instance);
```



## 2.4 员工信息编辑

![image-20240329153525768](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240329153525768.png)

![image-20240329153557479](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240329153557479.png)



# 3. 分类管理模块

直接导入



# 4. 菜品管理模块

## 4.1 新增菜品

![image-20240401105757863](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240401105757863.png)

![image-20240401105845100](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240401105845100.png)

![image-20240401105909754](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240401105909754.png)

![image-20240401105949012](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240401105949012.png)

![image-20240401110110945](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240401110110945.png)



### 4.1.1 文件上传

![image-20240401110528470](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240401110528470.png)



OSS:

![image-20240401144926754](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240401144926754.png)

```json
  {
      "Version": "1",
          "Statement": [{
      "Effect": "Allow",
              "Action": [
      "oss:*"
],
      "Principal": [
      "*"
],
      "Resource": [
      "acs:oss:*:1771931908752828:plumsnow",
              "acs:oss:*:1771931908752828:plumsnow/*"
],
      "Condition": {
          "StringEquals": {
              "oss:DataAccessPointAccount": [
              "1771931908752828"
       ]
          }
      }
  }]
  }
```



**1. 创建OssProperties实体类用于导入配置文件的各类属性**

```java
@Component
@ConfigurationProperties(prefix = "sky.alioss")
@Data
public class AliOssProperties {

    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketName;

}
```



**2. 创建文件上传配置类，导入OssProperties实体类，并用 @Bean 注解在启动时 new 一个**

```java
/**
 * 配置类 用于AliOssUtil
 */
@Configuration
@Slf4j
public class OssConfig {
    @Bean
    @ConditionalOnMissingBean // 如果没有这个bean，则创建
    public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties){
        log.info("开始创建阿里云文件上传工具类对象：{}", aliOssProperties);

        return new AliOssUtil(
                aliOssProperties.getEndpoint(),
                aliOssProperties.getAccessKeyId(),
                aliOssProperties.getAccessKeySecret(),
                aliOssProperties.getBucketName());
    }
```



**3. 创建文件上传工具类**

```java
@Data
@AllArgsConstructor
@Slf4j
public class AliOssUtil {

    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketName;

    /**
     * 文件上传
     *
     * @param bytes
     * @param objectName
     * @return
     */
    public String upload(byte[] bytes, String objectName) {

        // 创建OSSClient实例。
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);

        try {
            // 创建PutObject请求。
            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));
        } catch (OSSException oe) {
            System.out.println("Caught an OSSException, which means your request made it to OSS, "
                    + "but was rejected with an error response for some reason.");
            System.out.println("Error Message:" + oe.getErrorMessage());
            System.out.println("Error Code:" + oe.getErrorCode());
            System.out.println("Request ID:" + oe.getRequestId());
            System.out.println("Host ID:" + oe.getHostId());
        } catch (ClientException ce) {
            System.out.println("Caught an ClientException, which means the client encountered "
                    + "a serious internal problem while trying to communicate with OSS, "
                    + "such as not being able to access the network.");
            System.out.println("Error Message:" + ce.getMessage());
        } finally {
            if (ossClient != null) {
                ossClient.shutdown();
            }
        }

        //文件访问路径规则 https://BucketName.Endpoint/ObjectName
        StringBuilder stringBuilder = new StringBuilder("https://");
        stringBuilder
                .append(bucketName)
                .append(".")
                .append(endpoint)
                .append("/")
                .append(objectName);

        log.info("文件上传到:{}", stringBuilder.toString());

        return stringBuilder.toString();
    }
}
```



**4. 创建通用类，自动注入文件上传工具类使用**

```java
@Slf4j
@Api(tags = "通用接口")
@RestController
@RequestMapping("/admin/common")
public class CommonController {

    @Autowired
    private AliOssUtil aliOssUtil;

    /**
     * 文件上传
     * @param file
     * @return
     */
    @PostMapping("/upload")
    @ApiOperation("文件上传")
    public Result<String> upload(MultipartFile file){
        log.info("上传文件信息：{}", file);

        try {
            //获取原始文件名
            String orignalName = file.getOriginalFilename();
            //截取原始文件名后缀，这个方法的截取包含.
            String suffix = orignalName.substring(orignalName.lastIndexOf("."));
            //获取随机UUID并拼接原始后缀
            String newFileName = UUID.randomUUID().toString() + suffix;

            String fileUrl = aliOssUtil.upload(file.getBytes(), newFileName);
            return Result.success(fileUrl);

        } catch (IOException e) {
            log.error(MessageConstant.UPLOAD_FAILED, e);
        }

        return Result.error(MessageConstant.UPLOAD_FAILED);
    }


}
```



# ......



# 5. 用户端

![image-20240407095009222](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407095009222.png)



## 5.1 HttpClient

![image-20240407095213484](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407095213484.png)

![image-20240407095220777](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407095220777.png)

![image-20240407095233663](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407095233663.png)

![image-20240407095339219](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407095339219.png)



示例：

```java
package com.sky.test;

import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.json.JSONObject;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.IOException;

@SpringBootTest
public class HttpClientTest {
    /**
     * GET方法请求
     */
    @Test
    public void get(){
        //创建HttpClient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        //创建Http请求对象
        HttpGet httpGet = new HttpGet("http://localhost:8080/user/shop/status");

        //调用HttpClient的execute方法发送请求
        try {
            CloseableHttpResponse httpResponse = httpClient.execute(httpGet);

            //获取服务端返回的状态码
            int statusCode = httpResponse.getStatusLine().getStatusCode();
            System.out.println("服务端返回的状态码" + statusCode);

            //获取服务端返回的数据
            HttpEntity entity = httpResponse.getEntity();
            String body = EntityUtils.toString(entity);
            System.out.println("服务端返回的数据" + body);


            //关闭连接
            httpResponse.close();
            httpClient.close();

        } catch (IOException e) {
            throw new RuntimeException(e);
        }

    }

    /**
     * POST方法请求
     */
    @Test
    public void post() throws Exception{
        //创建HttpClient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        //创建Http请求对象
        HttpPost httpPost = new HttpPost("http://localhost:8080/admin/employee/login");

        JSONObject jsonObject = new JSONObject();
        jsonObject.put("username","admin");
        jsonObject.put("password","123456");

        //设置请求体
        StringEntity entity = new StringEntity(jsonObject.toString());
        entity.setContentEncoding("UTF-8");
        entity.setContentType("application/json");
        httpPost.setEntity(entity);

        //调用HttpClient的execute方法发送请求
        CloseableHttpResponse httpResponse = httpClient.execute(httpPost);

        //获取服务端返回的状态码
        int statusCode = httpResponse.getStatusLine().getStatusCode();
        System.out.println("服务端返回的状态码" + statusCode);

        //获取服务端返回的数据
        HttpEntity responseEntity = httpResponse.getEntity();
        String body = EntityUtils.toString(responseEntity);
        System.out.println("服务端返回的数据" + body);


        //关闭连接
        httpResponse.close();
        httpClient.close();
    }

}
```



项目已经封装：

```java
package com.sky.utils;

import com.alibaba.fastjson.JSONObject;
import org.apache.http.NameValuePair;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Http工具类
 */
public class HttpClientUtil {

    static final  int TIMEOUT_MSEC = 5 * 1000;

    /**
     * 发送GET方式请求
     * @param url
     * @param paramMap
     * @return
     */
    public static String doGet(String url,Map<String,String> paramMap){
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        String result = "";
        CloseableHttpResponse response = null;

        try{
            URIBuilder builder = new URIBuilder(url);
            if(paramMap != null){
                for (String key : paramMap.keySet()) {
                    builder.addParameter(key,paramMap.get(key));
                }
            }
            URI uri = builder.build();

            //创建GET请求
            HttpGet httpGet = new HttpGet(uri);

            //发送请求
            response = httpClient.execute(httpGet);

            //判断响应状态
            if(response.getStatusLine().getStatusCode() == 200){
                result = EntityUtils.toString(response.getEntity(),"UTF-8");
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            try {
                response.close();
                httpClient.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return result;
    }

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost(String url, Map<String, String> paramMap) throws IOException {
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = "";

        try {
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            // 创建参数列表
            if (paramMap != null) {
                List<NameValuePair> paramList = new ArrayList();
                for (Map.Entry<String, String> param : paramMap.entrySet()) {
                    paramList.add(new BasicNameValuePair(param.getKey(), param.getValue()));
                }
                // 模拟表单
                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList);
                httpPost.setEntity(entity);
            }

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), "UTF-8");
        } catch (Exception e) {
            throw e;
        } finally {
            try {
                response.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return resultString;
    }

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost4Json(String url, Map<String, String> paramMap) throws IOException {
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = "";

        try {
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            if (paramMap != null) {
                //构造json格式数据
                JSONObject jsonObject = new JSONObject();
                for (Map.Entry<String, String> param : paramMap.entrySet()) {
                    jsonObject.put(param.getKey(),param.getValue());
                }
                StringEntity entity = new StringEntity(jsonObject.toString(),"utf-8");
                //设置请求编码
                entity.setContentEncoding("utf-8");
                //设置数据类型
                entity.setContentType("application/json");
                httpPost.setEntity(entity);
            }

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), "UTF-8");
        } catch (Exception e) {
            throw e;
        } finally {
            try {
                response.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return resultString;
    }
    private static RequestConfig builderRequestConfig() {
        return RequestConfig.custom()
                .setConnectTimeout(TIMEOUT_MSEC)
                .setConnectionRequestTimeout(TIMEOUT_MSEC)
                .setSocketTimeout(TIMEOUT_MSEC).build();
    }

}
```



## 5.2 微信小程序开发

![image-20240407102558171](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407102558171.png)

https://mp.weixin.qq.com/wxopen/waregister?action=step1



#### 微信小程序 id / 密钥

| AppID(小程序ID)           |          wx6ac27855b9675112          |
| ------------------------- | :----------------------------------: |
| **AppSecret(小程序密钥)** | **fb1731ec91f5a8ffa5b44ab19fac3991** |



## 5.3 微信小程序目录结构

![image-20240407105928062](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407105928062.png)

![image-20240407110042552](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407110042552.png)



## 5.4 微信登录

![image-20240407141233031](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407141233031.png)



### 5.4.1 登录请求

**登录请求：**

```text
GET https://api.weixin.qq.com/sns/jscode2session
```

| 属性       | 类型   | 必填 | 说明                                                         |
| :--------- | :----- | :--- | :----------------------------------------------------------- |
| appid      | string | 是   | 小程序 appId                                                 |
| secret     | string | 是   | 小程序 appSecret                                             |
| js_code    | string | 是   | 登录时获取的 code，可通过[wx.login](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html)获取 |
| grant_type | string | 是   | 授权类型，此处只需填写 authorization_code                    |



**返回参数**

| 属性        | 类型   | 说明                                                         |
| :---------- | :----- | :----------------------------------------------------------- |
| session_key | string | 会话密钥                                                     |
| unionid     | string | 用户在开放平台的唯一标识符，若当前小程序已绑定到微信开放平台账号下会返回，详见 [UnionID 机制说明](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html)。 |
| errmsg      | string | 错误信息                                                     |
| openid      | string | 用户唯一标识                                                 |
| errcode     | int32  | 错误码                                                       |



### 5.4.2 需求分析

![image-20240407143159391](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407143159391.png)

![image-20240407143417204](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407143417204.png)

![image-20240407143540798](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407143540798.png)



### 5.4.3 代码开发

![image-20240407143925641](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407143925641.png)

![image-20240407143944901](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240407143944901.png)



**登录逻辑：**

​	Controller 层获取封装的 前端传回的小程序 code

​	Service 层通过传入的 code 通过微信接口服务 ==> 

```java
/**
 * 获取微信openid
 * @param code
 * @return
 */
private String getOpenid(String code){
    //调用微信接口服务，获取当前用户openid
    Map<String, String> map = new HashMap<>();
    map.put("appid", weChatProperties.getAppid());
    map.put("secret", weChatProperties.getSecret());
    map.put("js_code", code);
    map.put("grant_type", "authorization_code");
    String json = HttpClientUtil.doGet(WX_LOGIN, map);

    //解析出回传JSON数据中的openid
    JSONObject jsonObject = JSON.parseObject(json);

    return jsonObject.getString("openid");
}
```

获取当前用户的 openid （微信用户唯一标识）并判空、判是否新用户（若是存回数据库）返回查询到的 User

​	Controller 生成 jwt 令牌，将 User 的信息和 jwt 令牌封装 VO 对象返回前端。



**拦截器逻辑：**

​	新建 User 拦截器 ==> 

```java
/**
 * jwt令牌校验的拦截器
 */
@Component
@Slf4j
public class JwtTokenUserInterceptor implements HandlerInterceptor {

    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //判断当前拦截到的是Controller的方法还是其他资源
        if (!(handler instanceof HandlerMethod)) {
            //当前拦截到的不是动态方法，直接放行
            return true;
        }

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getUserTokenName());

        //2、校验令牌
        try {
            log.info("jwt校验:{}", token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getUserTokenName(), token);
            Long userId = Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString());
            log.info("当前用户id：{}", userId);
            BaseContext.setCurrentId(userId);
            //3、通过，放行
            return true;
        } catch (Exception ex) {
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        }
    }
}
```



附 jwt 令牌配置（从 application.yml 获取）：

```java
@Component
@ConfigurationProperties(prefix = "sky.jwt")
@Data
public class JwtProperties {

    /**
     * 管理端员工生成jwt令牌相关配置
     */
    private String adminSecretKey;
    private long adminTtl;
    private String adminTokenName;

    /**
     * 用户端微信用户生成jwt令牌相关配置
     */
    private String userSecretKey;
    private long userTtl;
    private String userTokenName;

}
```



​	在 WebMvcConfiguration 注册拦截器 ==> 

```java
/**
 * 注册自定义拦截器
 *
 * @param registry
 */
protected void addInterceptors(InterceptorRegistry registry) {
    log.info("开始注册自定义拦截器...");
    registry.addInterceptor(jwtTokenAdminInterceptor)
            .addPathPatterns("/admin/**")
            .excludePathPatterns("/admin/employee/login");

    registry.addInterceptor(jwtTokenUserInterceptor)
            .addPathPatterns("/user/**")
            .excludePathPatterns("/user/user/login")
            .excludePathPatterns("/user/shop/status");
}
```



# ......



# 6. 用户下单

## 6.1 需求分析

![image-20240408153856864](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240408153856864.png)

![image-20240408154054290](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240408154054290.png)

![image-20240408154504574](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240408154504574.png)

![image-20240408154620779](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240408154620779.png)

![image-20240408154741038](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240408154741038.png)

![image-20240408155231969](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240408155231969.png)



![image-20240408155252620](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240408155252620.png)

![image-20240408155445719](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240408155445719.png)



## 6.2 代码开发

![image-20240408153622542](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240408153622542.png)

![image-20240408153636021](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240408153636021.png)



# 7. 微信支付

![image-20240409092022650](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409092022650.png)

![image-20240409092138070](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409092138070.png)

![image-20240409092609106](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409092609106.png)



说明文档：https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_5_1.shtml

![image-20240409092934752](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409092934752.png)

![image-20240409093218188](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409093218188.png)



## 7.1 微信支付准备工作

![image-20240409093533821](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409093533821.png)

![image-20240409093806504](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409093806504.png)

使用 cpolar 进行内网穿透获取临时的公网地址

**使用：**

1. 在安装目录呼出 cmd 按照官网 “验证” 菜单下的要求配置隧道token

2. 在安装目录呼出 cmd ，输入 cpolar.exe http 8080 即可

![image-20240409094839180](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409094839180.png)



## 7.2 代码导入

![image-20240409095056969](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409095056969.png)

配置文件：

```yml
wechat:
  appid: ${sky.wechat.appid}
  secret: ${sky.wechat.secret}
  mchid : ${sky.wechat.mchid}
  mchSerialNo: ${sky.wechat.mchSerialNo}
  privateKeyFilePath: ${sky.wechat.privateKeyFilePath}
  apiV3Key: ${sky.wechat.apiV3Key}
  weChatPayCertFilePath: ${sky.wechat.weChatPayCertFilePath}
  notifyUrl: ${sky.wechat.notifyUrl}
  refundNotifyUrl: ${sky.wechat.refundNotifyUrl}
```



controller：

```java
/**
 * 订单支付
 *
 * @param ordersPaymentDTO
 * @return
 */
@PutMapping("/payment")
@ApiOperation("订单支付")
public Result<OrderPaymentVO> payment(@RequestBody OrdersPaymentDTO ordersPaymentDTO) throws Exception {
    log.info("订单支付：{}", ordersPaymentDTO);
    OrderPaymentVO orderPaymentVO = ordersService.payment(ordersPaymentDTO);
    log.info("生成预支付交易单：{}", orderPaymentVO);
    return Result.success(orderPaymentVO);
}
```



service：

```java
@Service
public class OrdersServiceImpl extends ServiceImpl<OrdersMapper, Orders> implements OrdersService {

    @Autowired
    private OrdersMapper orderMapper;
    @Autowired
    private WeChatPayUtil weChatPayUtil;
    @Autowired
    private UserService userService;
    @Autowired
    private OrdersService ordersService;

    /**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    public OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception {
        // 当前登录用户id
        Long userId = BaseContext.getCurrentId();
        User user = userService.getById(userId);

        //调用微信支付接口，生成预支付交易单
        JSONObject jsonObject = weChatPayUtil.pay(
                ordersPaymentDTO.getOrderNumber(), //商户订单号
                new BigDecimal(0.01), //支付金额，单位 元
                "苍穹外卖订单", //商品描述
                user.getOpenid() //微信用户的openid
        );

        if (jsonObject.getString("code") != null && jsonObject.getString("code").equals("ORDERPAID")) {
            throw new OrderBusinessException("该订单已支付");
        }

        OrderPaymentVO vo = jsonObject.toJavaObject(OrderPaymentVO.class);
        vo.setPackageStr(jsonObject.getString("package"));

        return vo;
    }

    /**
     * 支付成功，修改订单状态
     *
     * @param outTradeNo
     */
    public void paySuccess(String outTradeNo) {

        // 根据订单号查询订单
        Orders ordersDB = orderMapper.getByNumber(outTradeNo);

        // 根据订单id更新订单的状态、支付方式、支付状态、结账时间
        Orders orders = Orders.builder()
                .id(ordersDB.getId())
                .status(Orders.TO_BE_CONFIRMED)
                .payStatus(Orders.PAID)
                .checkoutTime(LocalDateTime.now())
                .build();

        LambdaUpdateWrapper<Orders> lambdaUpdateWrapper = new LambdaUpdateWrapper<>();
        lambdaUpdateWrapper.eq(Orders::getId, ordersDB.getId());
        ordersService.update(orders, lambdaUpdateWrapper);

    }


}
```



WeChatPayUtil：

```java
package com.sky.utils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.sky.properties.WeChatProperties;
import com.wechat.pay.contrib.apache.httpclient.WechatPayHttpClientBuilder;
import com.wechat.pay.contrib.apache.httpclient.util.PemUtil;
import org.apache.commons.lang.RandomStringUtils;
import org.apache.http.HttpHeaders;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.util.EntityUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.math.BigDecimal;
import java.security.PrivateKey;
import java.security.Signature;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.List;

/**
 * 微信支付工具类
 */
@Component
public class WeChatPayUtil {

    //微信支付下单接口地址
    public static final String JSAPI = "https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi";

    //申请退款接口地址
    public static final String REFUNDS = "https://api.mch.weixin.qq.com/v3/refund/domestic/refunds";

    @Autowired
    private WeChatProperties weChatProperties;

    /**
     * 获取调用微信接口的客户端工具对象
     *
     * @return
     */
    private CloseableHttpClient getClient() {
        PrivateKey merchantPrivateKey = null;
        try {
            //merchantPrivateKey商户API私钥，如何加载商户API私钥请看常见问题
            merchantPrivateKey = PemUtil.loadPrivateKey(new FileInputStream(new File(weChatProperties.getPrivateKeyFilePath())));
            //加载平台证书文件
            X509Certificate x509Certificate = PemUtil.loadCertificate(new FileInputStream(new File(weChatProperties.getWeChatPayCertFilePath())));
            //wechatPayCertificates微信支付平台证书列表。你也可以使用后面章节提到的“定时更新平台证书功能”，而不需要关心平台证书的来龙去脉
            List<X509Certificate> wechatPayCertificates = Arrays.asList(x509Certificate);

            WechatPayHttpClientBuilder builder = WechatPayHttpClientBuilder.create()
                    .withMerchant(weChatProperties.getMchid(), weChatProperties.getMchSerialNo(), merchantPrivateKey)
                    .withWechatPay(wechatPayCertificates);

            // 通过WechatPayHttpClientBuilder构造的HttpClient，会自动的处理签名和验签
            CloseableHttpClient httpClient = builder.build();
            return httpClient;
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 发送post方式请求
     *
     * @param url
     * @param body
     * @return
     */
    private String post(String url, String body) throws Exception {
        CloseableHttpClient httpClient = getClient();

        HttpPost httpPost = new HttpPost(url);
        httpPost.addHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.toString());
        httpPost.addHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.toString());
        httpPost.addHeader("Wechatpay-Serial", weChatProperties.getMchSerialNo());
        httpPost.setEntity(new StringEntity(body, "UTF-8"));

        CloseableHttpResponse response = httpClient.execute(httpPost);
        try {
            String bodyAsString = EntityUtils.toString(response.getEntity());
            return bodyAsString;
        } finally {
            httpClient.close();
            response.close();
        }
    }

    /**
     * 发送get方式请求
     *
     * @param url
     * @return
     */
    private String get(String url) throws Exception {
        CloseableHttpClient httpClient = getClient();

        HttpGet httpGet = new HttpGet(url);
        httpGet.addHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.toString());
        httpGet.addHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.toString());
        httpGet.addHeader("Wechatpay-Serial", weChatProperties.getMchSerialNo());

        CloseableHttpResponse response = httpClient.execute(httpGet);
        try {
            String bodyAsString = EntityUtils.toString(response.getEntity());
            return bodyAsString;
        } finally {
            httpClient.close();
            response.close();
        }
    }

    /**
     * jsapi下单
     *
     * @param orderNum    商户订单号
     * @param total       总金额
     * @param description 商品描述
     * @param openid      微信用户的openid
     * @return
     */
    private String jsapi(String orderNum, BigDecimal total, String description, String openid) throws Exception {
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("appid", weChatProperties.getAppid());
        jsonObject.put("mchid", weChatProperties.getMchid());
        jsonObject.put("description", description);
        jsonObject.put("out_trade_no", orderNum);
        jsonObject.put("notify_url", weChatProperties.getNotifyUrl());

        JSONObject amount = new JSONObject();
        amount.put("total", total.multiply(new BigDecimal(100)).setScale(2, BigDecimal.ROUND_HALF_UP).intValue());
        amount.put("currency", "CNY");

        jsonObject.put("amount", amount);

        JSONObject payer = new JSONObject();
        payer.put("openid", openid);

        jsonObject.put("payer", payer);

        String body = jsonObject.toJSONString();
        return post(JSAPI, body);
    }

    /**
     * 小程序支付
     *
     * @param orderNum    商户订单号
     * @param total       金额，单位 元
     * @param description 商品描述
     * @param openid      微信用户的openid
     * @return
     */
    public JSONObject pay(String orderNum, BigDecimal total, String description, String openid) throws Exception {
        //统一下单，生成预支付交易单
        String bodyAsString = jsapi(orderNum, total, description, openid);
        //解析返回结果
        JSONObject jsonObject = JSON.parseObject(bodyAsString);
        System.out.println(jsonObject);

        String prepayId = jsonObject.getString("prepay_id");
        if (prepayId != null) {
            String timeStamp = String.valueOf(System.currentTimeMillis() / 1000);
            String nonceStr = RandomStringUtils.randomNumeric(32);
            ArrayList<Object> list = new ArrayList<>();
            list.add(weChatProperties.getAppid());
            list.add(timeStamp);
            list.add(nonceStr);
            list.add("prepay_id=" + prepayId);
            //二次签名，调起支付需要重新签名
            StringBuilder stringBuilder = new StringBuilder();
            for (Object o : list) {
                stringBuilder.append(o).append("\n");
            }
            String signMessage = stringBuilder.toString();
            byte[] message = signMessage.getBytes();

            Signature signature = Signature.getInstance("SHA256withRSA");
            signature.initSign(PemUtil.loadPrivateKey(new FileInputStream(new File(weChatProperties.getPrivateKeyFilePath()))));
            signature.update(message);
            String packageSign = Base64.getEncoder().encodeToString(signature.sign());

            //构造数据给微信小程序，用于调起微信支付
            JSONObject jo = new JSONObject();
            jo.put("timeStamp", timeStamp);
            jo.put("nonceStr", nonceStr);
            jo.put("package", "prepay_id=" + prepayId);
            jo.put("signType", "RSA");
            jo.put("paySign", packageSign);

            return jo;
        }
        return jsonObject;
    }

    /**
     * 申请退款
     *
     * @param outTradeNo    商户订单号
     * @param outRefundNo   商户退款单号
     * @param refund        退款金额
     * @param total         原订单金额
     * @return
     */
    public String refund(String outTradeNo, String outRefundNo, BigDecimal refund, BigDecimal total) throws Exception {
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("out_trade_no", outTradeNo);
        jsonObject.put("out_refund_no", outRefundNo);

        JSONObject amount = new JSONObject();
        amount.put("refund", refund.multiply(new BigDecimal(100)).setScale(2, BigDecimal.ROUND_HALF_UP).intValue());
        amount.put("total", total.multiply(new BigDecimal(100)).setScale(2, BigDecimal.ROUND_HALF_UP).intValue());
        amount.put("currency", "CNY");

        jsonObject.put("amount", amount);
        jsonObject.put("notify_url", weChatProperties.getRefundNotifyUrl());

        String body = jsonObject.toJSONString();

        //调用申请退款接口
        return post(REFUNDS, body);
    }
}
```



**调用路径：**

controller.payment --> service.payment -> weChatPayUtil.pay --> weChatPayUtil.jsapi --> weChatPayUtil.post --return--> weChatPayUtil.pay



**小程序调用外卖后端接口，支付成功后小程序展示结果，与外卖后端无关，支付成功后微信后台通过回调地址（weChatPayUtil.jsapi中的notify_url）调用 PayNotifyController.paySuccessNotify 通知外卖后端，PayNotifyController.paySuccessNotify 再返回到微信后端，不然微信后端会一直通知外卖后端**

![image-20240409102451946](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409102451946.png)



# 8. 订单管理......



# 9. 来单提醒 + 催单

## 9.1 WebSocket

![](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409151032765.png)

![image-20240409151320829](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409151320829.png)

![image-20240409151416280](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409151416280.png)



```java
package com.sky.WebSocket;

import org.springframework.stereotype.Component;
import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.PathParam;
import javax.websocket.server.ServerEndpoint;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * WebSocket服务
 */
@Component
@ServerEndpoint("/ws/{sid}")
public class WebSocketServer {

    //存放会话对象
    private static Map<String, Session> sessionMap = new HashMap();

    /**
     * 连接建立成功调用的方法
     */
    @OnOpen
    public void onOpen(Session session, @PathParam("sid") String sid) {
        System.out.println("客户端：" + sid + "建立连接");
        sessionMap.put(sid, session);
    }

    /**
     * 收到客户端消息后调用的方法
     *
     * @param message 客户端发送过来的消息
     */
    @OnMessage
    public void onMessage(String message, @PathParam("sid") String sid) {
        System.out.println("收到来自客户端：" + sid + "的信息:" + message);
    }

    /**
     * 连接关闭调用的方法
     *
     * @param sid
     */
    @OnClose
    public void onClose(@PathParam("sid") String sid) {
        System.out.println("连接断开:" + sid);
        sessionMap.remove(sid);
    }

    /**
     * 群发
     *
     * @param message
     */
    public void sendToAllClient(String message) {
        Collection<Session> sessions = sessionMap.values();
        for (Session session : sessions) {
            try {
                //服务器向客户端发送消息
                session.getBasicRemote().sendText(message);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

}
```



用配置类进行注册

```java
package com.sky.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.server.standard.ServerEndpointExporter;

/**
 * WebSocket配置类，用于注册WebSocket的Bean
 */
@Configuration
public class WebSocketConfiguration {

    @Bean
    public ServerEndpointExporter serverEndpointExporter() {
        return new ServerEndpointExporter();
    }

}
```



## 9.2 来单提醒

![image-20240409153819732](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409153819732.png)

在 user/OrderServiceImpl.paySuccess 中追加：

```java
//通过WebSocket向客户端发送消息
Map map = new HashMap();
map.put("type", 1);
map.put("orderId", ordersDB.getId());
map.put("orderNumber", "订单号：" + ordersDB.getNumber());

String json = JSON.toJSONString(map);
webSocketServer.sendToAllClient(json);
```



## 9.3 客户催单

![image-20240409154915839](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409154915839.png)



在 admin/OrderServiceImpl.paySuccess 中新增方法

```java
/**
 * 客户催单
 * @param id
 * @return
 */
@GetMapping("/reminder/{id}")
@ApiOperation("客户催单")
public Result reminder(@PathVariable("id") Long id){
    LambdaQueryWrapper<Orders> lambdaQueryWrapper = new LambdaQueryWrapper<>();
    lambdaQueryWrapper.eq(Orders::getId,id);
    Orders orders = ordersService.getOne(lambdaQueryWrapper);

    if(null == orders){
        throw new OrderBusinessException(MessageConstant.ORDER_NOT_FOUND);
    }

    Map map = new HashMap<>();
    map.put("type", 2);
    map.put("orderId", id);
    map.put("cintent", "订单号：" + orders.getId());

    String json = JSON.toJSONString(map);
    webSocketServer.sendToAllClient(json);

    return Result.success();
}
```



# 10. 数据统计

![image-20240409160228269](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409160228269.png)



## 10.1 前端图形化报表展示 Apache ECharts

官方网站：https://echarts.apache.org/handbook/zh/get-started/

![](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409160329759.png)

![image-20240409160350355](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409160350355.png)

![image-20240409161146452](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409161146452.png)





## 10.2 产品原型

![image-20240409161707109](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409161707109.png)

![image-20240409161846458](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409161846458.png)

![image-20240409161959089](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240409161959089.png)

![image-20240410154319424](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240410154319424.png)

![image-20240410160302027](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240410160302027.png)

![image-20240410162818974](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240410162818974.png)



# 11. 工作台......



# 12. 操作 Excel

## 12.1 Apache POI

![image-20240411100156205](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240411100156205.png)

![image-20240411100204017](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240411100204017.png)

![image-20240411100648931](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240411100648931.png)

例子：

```java
package com.sky.test;

import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;

@SpringBootTest
public class POITest {

    public void createAndWrite() throws Exception {
        //在内存中创建Excel文件
        XSSFWorkbook excel = new XSSFWorkbook();

        //在Excel中创建标签页
        XSSFSheet sheet = excel.createSheet("info");

        //创建行,编号从0开始
        XSSFRow row = sheet.createRow(0);

        //创建单元格,编号从0开始
        XSSFCell cell = row.createCell(0);

        //设置单元格的值
        cell.setCellValue("hello world");

        //创建单元格并设置单元格的值
        row.createCell(1).setCellValue("2");
        ;
        //将Excel写入到磁盘中
        FileOutputStream fileOutputStream = new FileOutputStream(new File("C:\\Users\\Administrator\\Desktop\\资料\\我的\\我的学习部分\\苍穹外卖\\test.xlsx"));
        excel.write(fileOutputStream);

        //关闭资源
        fileOutputStream.close();
        excel.close();
    }

    public void read() throws Exception{
        FileInputStream fileInputStream = new FileInputStream(new File("C:\\Users\\Administrator\\Desktop\\资料\\我的\\我的学习部分\\苍穹外卖\\test.xlsx"));
        //读取Excel文件
        XSSFWorkbook excel = new XSSFWorkbook(fileInputStream);

        //读取excel文件中第一个sheet页
        XSSFSheet sheet = excel.getSheetAt(0);

        //获取sheet页中最后一行有文字的行号
        int lastRowNum = sheet.getLastRowNum();

        //遍历sheet页中的所有行
        for(int i = 0; i <= lastRowNum; i++){
            XSSFRow row = sheet.getRow(i);
            String stringCellValue = row.getCell(0).getStringCellValue();
            String stringCellValue1 = row.getCell(1).getStringCellValue();
        
            System.out.println(stringCellValue + " " + stringCellValue1);
        }
        
        //关闭资源
        fileInputStream.close();
        excel.close();

    }


    public static void main(String[] args) throws Exception{

        //调用createAndWrite方法
        new POITest().createAndWrite();

        //调用read方法
        new POITest().read();

    }
}
```



## 12.2 数据导出

![image-20240411103653591](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240411103653591.png)

![image-20240411103821906](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240411103821906.png)

![image-20240411104113964](https://raw.githubusercontent.com/normalSp/imgSave/master/image-20240411104113964.png)













